import pandas as pd
import numpy as np
import logging

from omen_bot_v2 import config
from omen_bot_v2.core import strategy
from omen_bot_v2.core import data_utils # Assuming data_utils exists for loading data

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def analyze_entry_signals():
    """
    Loads data, calculates indicators, and analyzes the entry signals generated by MyStrategy.
    This script focuses purely on signal generation characteristics, not trade execution.
    """
    logging.info("Starting entry signal analysis...")

    # 1. Load Data
    # Assuming data_utils has a function to load and prepare data
    # For now, let's replicate the loading logic from backtester for simplicity
    try:
        price_df = pd.read_csv(config.PRICE_DATA_PATH, parse_dates=['timestamp'], index_col='timestamp')
        funding_df = pd.read_csv(config.FUNDING_RATE_DATA_PATH, parse_dates=['fundingRateTimestamp'])
        
        funding_df.rename(columns={'fundingRateTimestamp': 'timestamp', 'fundingRate': 'funding_rate'}, inplace=True)
        
        df = pd.merge(price_df, funding_df[['timestamp', 'funding_rate']], on='timestamp', how='left')
        df.set_index('timestamp', inplace=True)
        df['funding_rate'].fillna(method='ffill', inplace=True)
        
        # 2. Calculate Indicators
        df = strategy.calculate_indicators(df, long_sma_period=config.LONG_SMA_PERIOD)
        df.dropna(inplace=True)

        # Filter data up to BACKTEST_END_DATE for holdout
        backtest_end_datetime = pd.to_datetime(config.BACKTEST_END_DATE)
        df = df[df.index <= backtest_end_datetime]
        
        logging.info(f"Data loaded and prepared successfully. Analysis data range: {df.index.min()} to {df.index.max()}.")
        
    except FileNotFoundError as e:
        logging.error(f"Error: Data file not found. {e}")
        logging.error("Please run the data_utils script first to download the data.")
        return
    except Exception as e:
        logging.error(f"An unexpected error occurred during data loading: {e}")
        return

    # 3. Instantiate MyStrategy
    my_strategy = strategy.MyStrategy()

    buy_signals = []
    sell_signals = []

    # 4. Iterate and Analyze Signals
    logging.info("Analyzing signals...")
    for index, row in df.iterrows():
        signal = my_strategy.check_for_signal(row)
        if signal == "BUY":
            buy_signals.append(index)
        elif signal == "SELL":
            sell_signals.append(index)

    logging.info(f"Total BUY signals: {len(buy_signals)}")
    logging.info(f"Total SELL signals: {len(sell_signals)}")

    # --- Further Analysis (Example: Check subsequent price movement) ---
    # Define what constitutes a "large move" for analysis
    LARGE_MOVE_PCT = 0.007 # 0.7%
    LOOK_FORWARD_PERIODS = 6 # Look forward 6 hours (candles)

    successful_buy_signals = 0
    successful_sell_signals = 0

    logging.info(f"Analyzing signal effectiveness (large move >= {LARGE_MOVE_PCT:.1%} within {LOOK_FORWARD_PERIODS} periods)...")

    for i, (index, row) in enumerate(df.iterrows()):
        if index in buy_signals:
            # Check if a large upward move occurs after the BUY signal
            future_data = df.loc[index:].head(LOOK_FORWARD_PERIODS + 1) # +1 to include current candle
            if len(future_data) > LOOK_FORWARD_PERIODS:
                entry_price = future_data.iloc[0]['close']
                max_price_in_future = future_data.iloc[1:]['high'].max() # Exclude current candle's close
                if (max_price_in_future - entry_price) / entry_price >= LARGE_MOVE_PCT:
                    successful_buy_signals += 1
        
        if index in sell_signals:
            # Check if a large downward move occurs after the SELL signal
            future_data = df.loc[index:].head(LOOK_FORWARD_PERIODS + 1)
            if len(future_data) > LOOK_FORWARD_PERIODS:
                entry_price = future_data.iloc[0]['close']
                min_price_in_future = future_data.iloc[1:]['low'].min() # Exclude current candle's close
                if (entry_price - min_price_in_future) / entry_price >= LARGE_MOVE_PCT:
                    successful_sell_signals += 1

    buy_success_rate = (successful_buy_signals / len(buy_signals)) * 100 if len(buy_signals) > 0 else 0
    sell_success_rate = (successful_sell_signals / len(sell_signals)) * 100 if len(sell_signals) > 0 else 0

    logging.info(f"BUY Signal Effectiveness: {buy_success_rate:.2f}% ({successful_buy_signals}/{len(buy_signals)})")
    logging.info(f"SELL Signal Effectiveness: {sell_success_rate:.2f}% ({successful_sell_signals}/{len(sell_signals)})")
    logging.info("Entry signal analysis complete.")

if __name__ == '__main__':
    analyze_entry_signals()